<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>James J Porter</title><link href="http://jamesjporter.me/" rel="alternate"></link><link href="http://jamesjporter.me/feeds/all.atom.xml" rel="self"></link><id>http://jamesjporter.me/</id><updated>2013-06-14T00:00:00-05:00</updated><entry><title>Fun with Emacs Lisp</title><link href="http://jamesjporter.me/fun-with-emacs-lisp.html" rel="alternate"></link><updated>2013-06-14T00:00:00-05:00</updated><author><name></name></author><id>tag:jamesjporter.me,2013-06-14:fun-with-emacs-lisp.html</id><summary type="html">&lt;p&gt;An interseting thing about the world or modern programming is that many decisions have already been made for us. For example, what the the following code snippets&amp;nbsp;do?&lt;/p&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fun1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;

&lt;span class="n"&gt;fun1&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Javascript:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;fun1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;fun1&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The answer is, they print 36. But what about the equivalent code in Emacs&amp;nbsp;lisp?:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This throws an error: &lt;code&gt;(void-variable x)&lt;/code&gt;. Huh? What is going on? The answer is that most modern languages, including python and javascript, are lexically scoped, whereas emacs lisp, being many decades old, is dynamically scoped. What does this mean? It has to do with the resolution of free variables. In each code example above, &lt;code&gt;x&lt;/code&gt; is a free variable in the innermost function call because it is not passed as an argument and has no local definition. How is the definition of a free variable resolved then? In lexically scoped languages, the language looks for definitions of free variables in the immediate &lt;em&gt;lexical environment&lt;/em&gt;, whereas in dynamically scoped langauges, the language looks for definitions of free variables in the immediate &lt;em&gt;evaluating environment&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;This explains our differing results above. Python and javascript see a free variable &lt;code&gt;x&lt;/code&gt; in the definition of &lt;code&gt;fun2&lt;/code&gt;. They go look for a definition in the enclosing lexical scope (the definition of &lt;code&gt;fun1&lt;/code&gt;), see that here x is defined to be 12, and use 12 as the value for x. Emacs lisp, on other hand, does the following. Using &lt;code&gt;funcall&lt;/code&gt;, we asked it to call the following with argument &lt;code&gt;3&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;let&lt;/code&gt; statement says that during the evaluation of the following code, let the value of &lt;code&gt;x&lt;/code&gt; be 12. The keyword here is &lt;em&gt;evaluation&lt;/em&gt;. Emacs lisp allows &lt;code&gt;x&lt;/code&gt; to be 12 during the evaluation, which returns a function of &lt;code&gt;y&lt;/code&gt;. The evaluation is then over, so emacs lisp promptly forgets the value of &lt;code&gt;x&lt;/code&gt;! The lambda function returned has no notion of the fact that &lt;code&gt;x&lt;/code&gt; is twelve in its lexical environment; when this function is called by &lt;code&gt;funcall&lt;/code&gt; it is called in the global scope, in which there is no definition of &lt;code&gt;x&lt;/code&gt;, hence &lt;code&gt;(void-variable x)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This seems weird by modern lights, because most languages we write code in regularly are lexically scoped. Emacs lisp gets ever weirder though. Remember when I said that python and javascript &amp;#8220;go look for a definition in the enclosing lexical scope&amp;#8221;? That was sort of a lie. They don&amp;#8217;t really go looking through the text of your code trying to find definitions, what actually happens is that when &lt;code&gt;fun1&lt;/code&gt; evaluates, it doesn&amp;#8217;t just return a bare function, it returns a &lt;em&gt;closure&lt;/em&gt;, which is a data structure that includes the inner function &lt;em&gt;along with the definitions of the variables in its lexical environment&lt;/em&gt;. When python or javascript needs to know the value of &lt;code&gt;x&lt;/code&gt; during evaluation, they go look up its definition in the closure. You can&amp;#8217;t actually examine closures in the language itself; they&amp;#8217;re special and hidden away in the implementation. But let&amp;#8217;s go back to Elisp for a moment. When we&amp;nbsp;execute&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We get&amp;nbsp;back:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which is a function definition, pretty much what we expected. Notice that this expression evluated on its own (which is effectively what we were doing when we did the &lt;code&gt;funcall&lt;/code&gt; above) hs no way of figuring out what &lt;code&gt;x&lt;/code&gt; is (i.e. no closure containing a definition of &lt;code&gt;x&lt;/code&gt;). Where Emacs lisp gets weird is that it is possible to have lexical scoping, but its an optional feature that you have to turn on. Let&amp;#8217;s try&amp;nbsp;it:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lexical-binding&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now the second expression evaluates&amp;nbsp;to:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;closure&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aha! A closure! Because lexical scope was tacked onto Elisp decades after its creation, it doesn&amp;#8217;t hide closures away from you the way more modern languages do; they are right there, available to be inspected as data structures in the language itself. If we funcall this with 3 as an argument, we get 36, just like we did in python or javascript. Internally, they are doing the same thing with the closure, we as programmers are just not allowed to see it. Emacs lisp is adorably trusting; however, which means we can do stupidly silly things. The closure is just a list, so we can use it as we would any&amp;nbsp;other:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;cl&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The closure is now bound to the symbol &lt;code&gt;cl&lt;/code&gt;, and we can funcall&amp;nbsp;it:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;cl&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt; 36&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can also modify it,&amp;nbsp;e.g.:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;caadr &lt;/span&gt;&lt;span class="nv"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We set the &lt;code&gt;cdr&lt;/code&gt; of the &lt;code&gt;car&lt;/code&gt; of the &lt;code&gt;car&lt;/code&gt; of the &lt;code&gt;cdr&lt;/code&gt; of &lt;code&gt;cl&lt;/code&gt; to 5. This changes cl&amp;nbsp;to:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;closure&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And&amp;nbsp;now:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;cl&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;; =&amp;gt; 15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is hilarious, but as Gary Bernhardt said, &lt;a href="https://www.youtube.com/watch?v=kXEgk1Hdze0"&gt;if you ever actually do this then wat&lt;/a&gt;.&lt;/p&gt;</summary></entry><entry><title>“Welcome to a crazy experiment”</title><link href="http://jamesjporter.me/welcome-to-a-crazy-experiment.html" rel="alternate"></link><updated>2013-06-03T00:00:00-05:00</updated><author><name></name></author><id>tag:jamesjporter.me,2013-06-03:welcome-to-a-crazy-experiment.html</id><summary type="html">&lt;p&gt;Today was the first day of the summer 2013 batch of &lt;a href="http://www.hackerschool.com"&gt;Hacker School&lt;/a&gt;, in which I am a participant. The variety of wonderful people participating in this thing is excellent; I am very much looking forward to the rest of the&amp;nbsp;summer.&lt;/p&gt;
&lt;p&gt;I have a few ideas for what I might want to do/learn for the next three months; which&amp;nbsp;include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Making a minimally functional replacement for Blackboard, the crummy classroom management software that pretty much every University in the world uses. I don&amp;#8217;t imagine mine will ever be used; but it&amp;#8217;s a concrete project that will motivate me to learn about web&amp;nbsp;programming.&lt;/li&gt;
&lt;li&gt;Emacs Lisp. I&amp;#8217;d like to learn more about extending the editor and maybe write a minor mode or&amp;nbsp;two.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://julia-lang.org"&gt;Julia&lt;/a&gt;. Scientific programming is in a bit of a weird place right now. On the one hand, you have &lt;span class="caps"&gt;MATLAB&lt;/span&gt; and Mathematica, which are great at what they do, but are propreitary software, which is problematic in any number of ways. On the other hand, you have the python scientific computing stack (numpy, scipy, matplotlib, scikit-learn, etc.) which has been embraced by many forward-looking people in the community. These tools are wonderful, don&amp;#8217;t get me wrong&amp;#8212;they have been useful to me and I love them dearly. However, they are something of a hack. Python was certainly not designed from the ground up to be used for scientific computation, and this shows in many places (&lt;span class="caps"&gt;GIL&lt;/span&gt;, etc.). There&amp;#8217;s also R, but it has a pretty narrow focus on statistics. I think Julia is a exciting because it &lt;em&gt;is&lt;/em&gt; designed from the ground up to be used in a wide variety of scientific applications (like &lt;span class="caps"&gt;MATLAB&lt;/span&gt;/Mathematica) but is also open source (like R or the python stack). Julia is going nowhere but up and I&amp;#8217;d love to learn the language and maybe even contribute if I&amp;nbsp;can.&lt;/li&gt;
&lt;li&gt;Clojure? I did Scheme in &lt;span class="caps"&gt;CS151&lt;/span&gt; at UChicago and it was great, but I&amp;#8217;d like to learn a Lisp that&amp;#8217;s used in the &amp;#8220;real world&amp;#8221;. Clojure is what all the cool kids seem to be into these days, so it&amp;#8217;ll&amp;nbsp;do.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; hacking? I bought one of these things forever ago and then got really busy and never had time to play with it; I&amp;#8217;d love to fool around a&amp;nbsp;bit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is, admitedly, a fairly wide variety and large amount of stuff. I&amp;#8217;ll likely narrow my focus in the coming weeks and I&amp;#8217;m looking forward to learning new things and sharing with&amp;nbsp;others.&lt;/p&gt;</summary></entry></feed>